# ShoppingCart
#### 购物车的功能
```
1.加购(商品加入购物车).
2.购物车列表页.
3.结算下单.
```
#### 购物车实体类
```
暂存购物车 -LocalStorage
1.SKUID(商品ID).
2.count     加购商品数量.
3.timestamp 加购时间.
4.selected  勾选状态.
ps: 商品价格和总价、商品介绍、商品现在是否有获由其它实体表保存.
用户购物车 
1.服务端数据库存储
1.id        主键
2.user_id   用户id
3.sku_id    商品id
4.count     数量
5.timestamp 加购时间
6.selected  勾选状态
2.使用Redis存储,速度块，
  但是redis异步刷盘会丢失数据，复杂查询也不容易，购物车场景也是读少写多，缓存命中率低，不适合用cache-aside机制。
key -> user_id
value(hash)-> {"商品id":id,"count":2,"timestamp":123,"selected":false}
``` 
#### 购物车存储时把握的原则
```
1.用户未登录，在浏览器中加购，关闭浏览器再打开，刚才加购的商品还在不在?
  重启浏览器时，加购的商品依然保留在暂存购物车里.
2.用户未登录，在浏览器中加购，用户登录后，刚才加购的商品还在不在?
  用户登录后，暂存购物车的商品会合并在用户购物车中.暂存的购物车会被清空.
3.用户多次添加重复的商品，购物车会如何存储?
  购物车会将重复添加的商品进行合并(表现在数量上).
4.用户退出后，再打开购物车页面，购物车里面是否还有商品?
  用户退出后，再打开购物车页面,暂存购物车无商品，暂存购物车商品已在登陆时候清空.
5.用户打开手机，用相同的用户登录，加购的商品是否存在?
  用户用手机端登录时候，加购的商品还会存在.
```
#### 暂存购物车设计
```
1.暂存购物车存储位置.
  若存在服务端，例如存在数据库，session中。需要设计唯一性id，并且占据服务器存储空间，增加网络传输数据量.
  客户端可以存在Cookie或LocalStorage中。
  Cookie的缺点: 客户端在每次与服务器通信时候，都会携带Cookie.
               不同浏览器的Cookie的容量有区别，一般的阈值在4kb左右.
2.存储格式的选择.
  考虑存储单元大小与易读性，使用json作为存储单位.
{
    "cart":[
        {
            "SKUID":8888,
            "timestamp":1578721136,
            "count":1,
            "selected":true
        }
    ]
}
```
#### 商品突然降价问题
```
1.由于后台突然调整价格，导致用户购买后发现价格与前端显示的不一致.
  解决，数据库商品字段添加版本，当购买时，前端传递的商品版本与商品最新版本不一致购买失败.
```
#### 结算下单
```       
方式一:使用消息队列              
             -> 创建订单   -> 订单库
订单系统  ->
             -> 发送订单创建信息 -> 消息队列(异步通信,解耦和) -> 购物车系统 ->清理购物车
存在问题(异步关系，在分布式系统中一致性存在问题):
 1.成功创建订单，但是没有清理购物车.
   情况1.向mq发送消息失败.
      1.mq生产端可以开启事务机制，
      2.在事务开始后先向mq发送消息.
      3.执行订单入库操作.订单入库成功，消息发送成功.
      4.订单入库失败，发往mq的消息视为失败,相当于回滚操作.
      问题: 若事务提交失败如何处理?抛出异常，捕获异常不断的发送消息.
   情况2.mq消费者消费失败.
     消费端采取确认机制，mq broker服务器重新发送消息到客户端.
方式二: 分布式事务 2pc(二个过程提交才算事务的最终提交)
 需要一个事务协调者来保障多个事务完成
```
#### 整个调用流程
```
用户加购 -> 购物车模块创建相应购物信息
   购买 ->  
     分布式事务中
       流程可以用工作流框架编写
          1.库存模块检查库存
          2.订单模块下订单
          3.购物车模块清除购物信息
```

